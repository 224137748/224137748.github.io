# 基础知识

## 原始（Primitive）类型

::: danger 疑问
原始类型有哪几种？
null 是对象嘛？
为什么 typeof null 结果为 object?
:::

在 JS 中，存在着 6 种原始值，分别是：

- `boolean`
- `null`
- `undefined`
- `number`
- `string`
- `symbol`

首先原始类型存储的都是值，是没有函数可以调用的，比如`undefined.toString()`

而`'1'.toString()`是可以使用的，这是因为在这种情况下，`'1'`已经不是原始类型的了，它已经被强制转换成了`String`类型也就是对象类型，所以可以调用`toString()`函数。

除了会在必要的情况下强转类型以外，原始类型还有一些坑。

其中 JS 的 `number` 类型是 _浮点类型_ 的，在使用中会遇到某些 Bug，比如 `0.1 + 0.2 !== 0.3`，但是这一块的内容会在进阶部分讲到。`string` 类型是不可变的，无论你在 `string` 类型上调用何种方法，都不会对值有改变。

另外对于 `null` 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 `typeof null` 会输出 `object`，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，**为了性能考虑使用低位存储变量的类型信息，`000` 开头代表是对象，然而 `null` 表示为全零，所以将它错误的判断为 `object` 。** 虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

## 对象（Object）类型

::: danger 疑问
对象类型和原始类型的不同之处？
函数参数是对象会发生什么问题？
:::
对象类型的数据分别有:

- `function`
- `Object`
- `Array`

简而言之，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。

```js
const a = [];
```

对于常量`a`来说，假设内存地址（指针）为`#001`，那么在地址 `#001` 的位置存放了值 `[]`，常量 `a` 存放了地址（指针） `#001`，再看以下代码:

```js
const a = [];
const b = a;
b.push(1);
```

当我们将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），也就是说当前变量 `b` 存放的地址（指针）也是 `#001`，当我们进行数据修改的时候，就会修改存放在地址（指针） `#001` 上的值，也就导致了两个变量的值都发生了改变。

接下来我们来看函数参数是对象的情况

```js
function fn1(person) {
  person.age = 18;
  person = {
    name: "zhangsan",
    age: 30
  };
  return person;
}

const p1 = {
  name: "yyy",
  age: 25
};

const p2 = fn1(p1);

console.log(p1); // -> ?
console.log(p2); // -> ?
```

对于以上代码，解析如下：

- **首先，函数传参是传递对象指针的副本；**
- 当函数`fn1`执行完`person.age = 18`后，当前 `p1` 的值也被修改了，这里的`person`和`p1`指向的是同一个内存地址；
- 当执行`person = { name: 'yyy' }`语句时，`person`的指针已经被重新指派到`{ name: 'yyy' }`这个对象的存储地址去了。

所以`fn1`函数返回的对象`person`和传入的`person`，指向的是不同的内存地址。

## typeof vs instanceof

::: danger 疑问
typeof 是否能正确判断类型？
instanceof 能正确判断对象的原理是什么？
:::

`typeof` 对于原始类型来说，除了 `null` 都可以显示正确的类型

```js
typeof 1; // 'number'
typeof "1"; // 'string'
typeof undefined; // 'undefined'
typeof true; // 'boolean'
typeof Symbol(); // 'symbol'

typeof null; // 'object'
```

在上面的篇幅中已经解释了为什么`typeof null`结果为`object`。`typeof` 对于对象来说，除了函数都会显示 `object`，所以说 `typeof` 并不能准确判断变量到底是什么类型

```js
typeof []; // 'object'
typeof {}; // 'object'
typeof console.log; // 'function'
```

如果我们想判断一个对象的正确类型，这时候可以考虑使用 `instanceof`，因为内部机制是通过原型链来判断的。

```js
const Person = function() {};
const p1 = new Person();
p1 instanceof Person; // true

var str = "hello world";
str instanceof String; // false

var str2 = new String("hello world");
str2 instanceof String; // true
```

对于原始类型来说，想直接通过 `instanceof` 来判断类型是不行的
::: tip 拓展
有没有办法能让 `instanceof` 判断原始类型？
:::

```js
class PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === "string";
  }
}

console.log("hello world" instanceof PrimitiveString); // true
```

上述代码给`PrimitiveString`定义了一个静态方法，`Symbol.hasInstance`实际就是一个能让我们自己定义`instanceof`行为的“东西”，等同于 `typeof 'hello world' === 'string'`，所以结果自然是`true`了。
这说明，用`insatnceof`判断数据类型不是百分之百准确的。

::: tip 拓展
有没有什么方法可以判断一个变量是什么类型？（函数、数组、对象、boolean、Symbol...）
:::

```js
function checkVariableType(val) {
  let typeString = Object.prototype.toString.call(val);
  return typeString.substring(8, typeString.length - 1);
}
checkVariableType(); // Undefined
checkVariableType([]); // Array
```

控制台输出如下：
![image](/imgs/javascript/checkVarType.png)

## 数据类型转换

::: tip 注意
该类型的面试题经常再笔试中出现，需牢牢掌握!
:::

众所周知，`JS` 是一门松散型的编程语言，在开发过程中常常会对变量进行直接或者隐式转换，相对于传统的严谨型的语言各有千秋。在`JS`中**简单数据类型**的转换：

- 转换为字符串
- 转换为布尔值
- 转换为数字

转换对应关系：
原始值（类型）| 目标类型 | 结果
---|---|---
number | 布尔值 | 除了 0、-0、NAN,其余都为 true
string | 布尔值 | 非空字符串都为 true
undefined<br>null | 布尔值 | 都为 false
引用类型 | 布尔值 | 都为 true
boolean<br>function<br>Symbol | 字符串 | 字符串化 'true' 'Symbol(123)'
undefined<br>null | 字符串 | 'undefined' 'null'
数组 | 字符串 | **见备注**
对象 | 字符串 | "[object Object]"
string | 数字 | '2' => 2; 'a' => NAN
undefined<br>null | 数字 | undefined => NAN； null => 0
数组 | 数字 | 1、空数组为 0，[] => 0<br>2、存在一个元素且为数字或字符串数<br>字，转换为数字，['1'] => 1;[2] => 2;[1,2] => NAN<br>3、其余转换为 NAN

:::warning 备注
数组转换为字符串，将依次遍历数组中的元素，将每个元素转换成为字符串后拼接在一起。注意：undefined、null 将视为空值；
:::
![image](/imgs/javascript/transofrmString.png)

### 转 Boolean

在条件判断时，除了 `undefined`， `null`， `false`， `NaN`， `''`， `0`， `-0`，其他所有值都转为 1true1，包括所有对象。

### 对象转原始类型

对象在转换类型的时候，会调用内置的 `[[ToPrimitive]]` 函数，对于该函数来说，算法逻辑一般来说如下：

- 如果已经是原始类型了，那就不需要转换了
- 如果需要转字符串类型就调用 `x.toString()`，转换为基础类型的话就返回转换的值。不是字符串类型的话就先调用 `valueOf`，结果不是基础类型的话再调用 `toString`
- 调用 `x.valueOf()`，如果转换为基础类型，就返回转换的值
  如果都没有返回原始类型，就会报错

```js
var obj = {
  valueOf() {
    return 2;
  },
  toString() {
    return "hahha";
  }
};
console.log(obj * 2); //  4
console.log(String(obj)); // hahha
```

![image](/imgs/javascript/objTranformString.png)
当然也可以重写 `Symbol.toPrimitive` ，该方法在转原始类型时调用优先级最高。

```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return "1";
  },
  [Symbol.toPrimitive]() {
    return 2;
  }
};
1 + a; // => 3
```

## 隐式转换

### 四则运算

加法运算符不同于其他几个运算符，它有以下几个特点：

- 运算中其中一方为字符串，那么就会把另一方也转换为字符串
- 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

```js
1 + "1"; // '11'
true + true; // 2
4 + [1, 2, 3]; // "41,2,3"
```

解析如下：

- 对于第一行代码来说，触发特点一，所以将数字`1` 转换为字符串，得到结果 `'11'`
- 对于第二行代码来说，触发特点二，所以将 `true` 转为数字 `1`
- 对于第三行代码来说，触发特点二，所以将数组通过 `toString` 转为字符串 `1,2,3`，得到结果 `41,2,3`

另外对于加法还需要注意这个表达式 `'a' + + 'b'`

```js
"a" + +"b"; // -> "aNaN"
```

因为 `+ 'b'` 等于 `NaN`，所以结果为 `"aNaN"`，你可能也会在一些代码中看到过 `+ '1'` 的形式来快速获取`number`类型。

那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字

```js
4 * "3"; // 12
4 * []; // 0
4 * [1, 2]; // NaN
```

### 比较运算符

1. 如果是对象，就通过 toPrimitive 转换对象
2. 如果是字符串，就通过 unicode 字符索引来比较

```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return "1";
  }
};
a > -1; // true
```

在以上代码中，因为 `a` 是对象，所以会通过 `valueOf` 转换为原始类型再比较值。
